-- drop table if exists paid_parking.entry;
create table paid_parking.entry (
	id integer not null primary key generated by default as identity,
	plate text not null,
	msisdn text not null,
	activation_time timestamp with time zone not null default current_timestamp,
	expiration_time timestamp with time zone not null,
	location_id integer not null references paid_parking.region(id)
);

-- drop type if exists paid_parking.pp_business_hours
create type paid_parking.pp_business_hours as (
 dow integer, -- 1 is Monday, 7 is Sunday
 pp_from time with time zone,
 pp_till time with time zone
);

-- drop table if exists paid_parking.region;
create table paid_parking.region (
 id integer not null primary key generated by default as identity,
 name text,
 price numeric not null,
 period interval not null,
 short_number text not null,
 business_hours paid_parking.pp_business_hours[]
);

create or replace trigger forbid_update_and_delete
before update or delete on paid_parking.entry 
for each row execute function paid_parking.forget_it();

create or replace trigger calculate_expiration
before insert on paid_parking.entry
for each row execute function paid_parking.calculate_expiration_f();

create table paid_parking.exceptions (
	region_id integer, 
	day timetz not null,
	name text not null
)

create or replace function paid_parking.register_payment(caller_msisdn text, 
arg_short_number text, plate text)
returns table(
	status_code integer not null,
	expiration_time timestamp with time zone
)
$$
declare
	region_id integer;
	region_name text;
	region_price numeric;
	region_period interval not null;
	working_hours_list paid_parking.pp_business_hours[];
	in_business_hours boolean;
begin
	select id, name, price, period, business_hours from paid_parking.region
	where arg_short_number = region.short_number
	into region_id, region_name, region_price, region_period, working_hours_list;
	select region_id, name, day from paid_parking.exceptions
	into exception_region_id, exception_name, exception_day;
	is_business_hours := exists(
	select 1 from unnest(working_hours_list) as t 
	where t.dow = extract('isodow' from current_timestamp)	
	and current_timestamp::timetz between t.pp_from and t.pp_till);
	if is_business_hours then 
		status_code := 0;
		expiration_time := current_time + region_period;
	else
		status_code := 1;
		expiration_time := null;
	end if;
	return next;
end;
$$;

--need to insert a new payment event, need to add holidays as exceptions,
--can use the calculate_expiration_f function as a helper

create or replace function paid_parking.calculate_expiration_f()
returns trigger language plpgsql as
$$
declare
	remaining_time interval;
begin
 select period from paid_parking.region where id = new.location_id 
 into remaining_time;
 if current_time >= pp_till then new.activation_time := pp_from --pp_from is for the next day
 new.expiration_time := new.activation_time + remaining_time;
 return new;
end;
$$;

create or replace function paid_parking.forget_it() 
returns trigger language plpgsql as
$$
begin
 raise log 'Attempt to % on % by %', TG_OP, current_timestamp, current_user;
 return null;
end;
$$;

insert into region (price, period, name, short_number) 
values (1.50, '1 hour', 'Златица', '123');
select * from region;


insert into entry(plate, msisdn, activation_time, expiration_time, location_id)
values ('CB4599KB', '359888123456', now(), now() + interval '1.5 hours', 1);

insert into entry(plate, msisdn, activation_time, location_id)
values ('CB4599KB', '359888123456', now() + interval '1.5 hours', 1);

select * from entry;

delete from entry where true;
update entry set msisdn = 'whatever';
--Written by Alexander Radoykov 11v
--also used some code from Stefan Stefanov repo.

--table City
create table if not exists  city (
   	id integer not null primary key generated by default as identity,
    name varchar(50) unique not null
);

--table Zone
create table if not exists zone (
  	id integer not null primary key generated by default as identity,
    city_id int not null references city(id),
    name varchar(50) not null,
    unique (city_id, name)
);

--table Zone info
create table if not exists zone_info (
    zone_id int not null references zone(id),
    weekday smallint not null check(weekday between 0 and 6) ,
    zone_start_time  time with time zone not null,
    zone_end_time  time with time zone not null,
    max_permissible_stay interval not null,
    period interval not null,
    price numeric(10,2) not null,
    primary key (zone_id, weekday)
);

--table ticket
create table if not exists ticket (
	id integer not null primary key generated by default as identity,
   	car_plate varchar(10) not null,
    msisdn varchar(18),
    zone_id int not null references zone(id),
    session_start timestamp with time zone not null default current_timestamp,
    session_end timestamp with time zone not null
);

--for fast search
create index idx_zones_city on zone(city_id);
create index idx_zone_info on zone_info(zone_id, weekday);
create index idx_ticket_zone on ticket(zone_id);

--sample data
insert into city(name) values
('Златна Панега'),
('Златица'),
('Луковит');

insert into zone(city_id, name) values
(1, 'зелена'),
(3, 'червена'),
(2, 'синя');

--specific in posgres

insert into zone_info(zone_id, weekday, zone_start_time, zone_end_time, max_permissible_stay, period, price) values
(1, 1, '05:30', '20:30', '05:00', '01:00', 2.20),
(1, 2, '05:30', '20:30', '05:00', '01:00', 2.20),
(1, 3, '05:30', '20:30', '05:00', '01:00', 2.20),
(1, 4, '05:30', '20:30', '05:00', '01:00', 2.20),
(1, 5, '05:30', '20:30', '05:00', '01:00', 2.20),
(1, 6, '05:30', '20:30', '05:00', '01:00', 2.20),
(1, 0, '05:30', '20:30', '05:00', '01:00', 2.20),
(2, 6, '08:00', '20:00', '06:00', '01:00', 1.10),
(3, 6, '06:30', '22:30', '03:00', '01:00', 3.00);

--delete from ticket;
insert into ticket(car_plate, msisdn,  zone_id) values 
('CB4599KB', '359888123456', 1),
('CB0000KB', '399988789817', 2),
('CBXXXXKB', '399988789817', 3),
('CBXXXXKB', '399988789817', 1);

select * from ticket;



--register payment
create or replace function register_payment_f()
returns trigger
language plpgsql
as $$
declare
	zone_info_r record;
	count_of_tickets integer;

	last_start timestamp with time zone;
 	last_end timestamp with time zone;

    curr_dow int := extract(dow from new.session_start)::int;
begin
	--gets zone_info props
 	select zone_start_time, zone_end_time, max_permissible_stay, period
    into zone_info_r
    from zone_info
    where zone_id = new.zone_id and weekday = curr_dow;

    if not found then
        raise exception 'No zone_info found for zone_id=% and weekday=%',
            new.zone_id, curr_dow;
    end if;
	
	--check if it is free
	if not new.session_start::time between zone_info_r.zone_start_time and zone_info_r.zone_end_time then
		raise exception 'It is free now : %', current_timestamp;
    end if;

	--checks for more tickets
	select session_start, session_end,
    count(*) over () as ticket_count   --window function !
	into last_start, last_end, count_of_tickets
	from ticket t
	where t.car_plate = new.car_plate --SMS could be send from different phones for only one car
	order by t.session_end desc
	limit 1; 
		
		if count_of_tickets is null then 
			count_of_tickets := 0;
		end if;
	--checks for downtime exceeded
		if count_of_tickets * zone_info_r.period + zone_info_r.period > zone_info_r.max_permissible_stay then --including this ticket
			raise exception 'Exceeded max hour of duration : %, max stay : %',
            count_of_tickets * zone_info_r.period, zone_info_r.max_permissible_stay;
		end if; 

	--calculate rest time
	if count_of_tickets = 0 then
		new.session_end := new.session_start + zone_info_r.period;
	else
		new.session_start := last_start;
		new.session_end := last_end + zone_info_r.period;
	end if;
   
    return new;
end;
$$;

create or replace trigger register_payment_t
before insert on ticket
for each row execute function  register_payment_f();

--gets the status of payment for car
create or replace function is_plate_number_paid(car_plate_var varchar(10))
returns boolean
language plpgsql
as $$
declare
	last_end timestamp with time zone;
begin
	select session_end
	into last_end
	from ticket t
	where t.car_plate = car_plate_var
	order by t.session_end desc
	limit 1; 

	if not found then
		return false;
	end if;

	if now() > last_end then 
		return false; 
	end if;

	return true;
end;
$$;

select is_plate_number_paid('CBXXXXKB');
select * from ticket;

--gets cars to be expired in 5 minutes
create or replace function soon_expired_5()
returns setof ticket
language sql 
as $$
    select *
    from ticket t
    where t.session_end > now()
      and t.session_end <= now() + interval '5 minutes'
    order by t.session_end;
$$;

select soon_expired_5();

--analytics and reporting
--drop schema paid_parking cascade;
--create schema paid_parking;

select car_plate, c.name, count(*)
from ticket t
join zone z on z.id = t.zone_id
join zone_info z_f on z_f.zone_id = z.id
join city c on c.id = z.city_id
group by car_plate, c.name;

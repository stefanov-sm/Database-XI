## Window functions
### aggregation of "what you see through a window" (i.e. a data frame)
A good introduction to window functions [here](https://boringsql.com/posts/window-functions-introduction/)  
> [!important]
> :bulb: From the [documentation](https://www.postgresql.org/docs/current/tutorial-window.html): A window function performs a calculation across a set of table rows that are somehow related to the current row. This is comparable to the type of calculation that can be done with an aggregate function. However, window functions do not cause rows to become grouped into a single output row like non-window aggregate calls would. Instead, the rows retain their separate identities. Behind the scenes, the window function is able to access more than just the current row of the query result.

### Illustration
- Create a sample table with initial ballance, spendings and earnings
```sql
create table wf 
(
id integer primary key generated by default as identity,
event_date date not null,
amount numeric not null,
owner text not null,
notes text
);
```
- Populate it with data
```sql
-- initial ballance
insert into wf (event_date, amount, owner) values ('2000-01-01', 2300, 'Александър');
-- 1000 rows
insert into wf (event_date, amount, owner)
select '2000-01-01'::date + random(0, 110000), random(-1000, 1000), 'Александър'
from generate_series(1, 1000);
-- and two more people
insert into wf (event_date, amount, owner) values ('2000-01-01', 2000, 'Виктор');
insert into wf (event_date, amount, owner)
select '2000-01-01'::date + random(0, 110000), random(-1000, 1000), 'Виктор'
from generate_series(1, 1000);

insert into wf (event_date, amount, owner) values ('2000-01-01', 2500, 'Борис');
insert into wf (event_date, amount, owner)
select '2000-01-01'::date + random(0, 110000), random(-1000, 1000), 'Борис'
from generate_series(1, 1000);
```
- overall earning, expenditure and ballance on daily basis using a CTE. Note the COALESCE
```sql
with t as (
select event_date, owner,
 coalesce(sum(amount) filter (where amount < 0) 
  over (
  		partition by owner 
  		order by event_date 
  		rows between unbounded preceding and current row
  	   ), 0) as expenditure,
 sum(amount) filter (where amount > 0) 
   over (
  		partition by owner 
  		order by event_date 
  		rows between unbounded preceding and current row
  	   ) as earning
from wf
)
select *, earning + expenditure as ballance 
from t order by event_date;
```

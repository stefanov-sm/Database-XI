## The "hard" parts of database management
### Handling NULL

Null (of Latin origin) means **none, nothing**. In information context I would prefer to say **I don't know**.
> [!NOTE]  
> NULLs are tricky  
> **Any expression - no matter how long or complex - containing a NULL value is "poisoned" to return NULL**
#### Examples  
```sql
SELECT (3 + null) / 2; -- arithmetic, yieldws NULL
SELECT NULL > 0; -- boolean, yields NULL
-- NB! NULLS do not compare
SELECT NULL = NULL; -- boolean, yields NULL
SELECT NULL <> NULL; -- boolean, yields NULL
```
Exceptions:
```sql
SELECT NULL > 0 OR TRUE; -- yields TRUE
SELECT NULL > 0 AND FALSE; -- yields FALSE
```
> [!NOTE]  
> A NULL-valued logical expression is treated as FALSE  
> But there is a trap  
> **Beware: two opposite logicql expressions end up with the same result**
```sql
SELECT case when NULL > 0 then 'Apple' else 'Pear' end; -- yields 'Pear'
SELECT case when NOT (NULL > 0) then 'Apple' else 'Pear' end; -- yields 'Pear'
```
* Не знам **е по-голямо нула?** (poisoned) -> Не знам -> FALSE -> круша.
* Не знам **не е по-голямо от нула?** (poisoned) -> Не знам -> FALSE -> круша.

### NULL-handling operators
**IS NULL/IS NOT NULL operator**
```sql
SELECT 3 is null; -- yields FALSE
SELECT 3 is not null; -- yields TRUE
SELECT NULL is null; -- yields TRUE
```
**COALESCE** pseudo-function (of Latin origin) - returns the first non-null argument  
Antivenom, replacing NULLs with default values
```sql
SELECT COALESCE(null, 3); -- yields 3
SELECT COALESCE(null, null, 'домат'); -- yields 'домат'
SELECT COALESCE('yeah', null, 'nope'); -- yields 'yeah'
```
**IS DISTINCT FROM/IS NOT DISTINCT FROM** - NULL-sensitive comparison operator
```sql
SELECT NULL is not distinct from NULL; -- yields TRUE
```
### Character data
Character data types (char, varchar, text) have two critically important attributes: [encoding and collation](https://www.postgresql.org/docs/current/multibyte.html#MULTIBYTE)   
Read this very good stuff on [character encodings](https://thebuild.com/blog/2024/10/27/speaking-in-tongues-postgresql-and-character-encodings/) & [collations and locales](https://thebuild.com/blog/2024/10/25/postgresql-collations-1-gentlemen-this-is-a-football/) (5 minutes read)

### Temporal data types (i.e. related to time) - DATE, TIME, TIMESTAMP, INTERVAL
> [!NOTE]  
> Always use [ISO-8601 notation](https://en.wikipedia.org/wiki/ISO_8601) for textual representation of temporal data types  
> but be prepared that data coming from an external source may use a different notation  

A leap ahead - the `::` operator (PostgreSQL specific) casts the left operand to a certain type (the right one)
* **DATE data type**
```sql
SELECT current_date;
SELECT '2025-10-02'::date;
SELECT '2025-10-02'::date + 1; -- yields the third of October
```
Data type rule:
* DATE (+ or -) INTEGER -> DATE. The INTEGER is treated as number of days
* DATE + DATE -> :boom:
  
* **TIME data type**



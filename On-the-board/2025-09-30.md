# "Hard" parts of database management
## Handling NULL

Null (of Latin origin) means **none, nothing**. In information context I would prefer to say **I don't know**.
> [!NOTE]  
> NULLs are tricky  
> **Any expression - no matter how long or complex - containing a NULL value is "poisoned" to return NULL**
#### Examples  
```sql
SELECT (3 + null) / 2; -- arithmetic, yieldws NULL
SELECT NULL > 0; -- boolean, yields NULL
-- NB! NULLS do not compare
SELECT NULL = NULL; -- boolean, yields NULL
SELECT NULL <> NULL; -- boolean, yields NULL
```
Exceptions:
```sql
SELECT NULL > 0 OR TRUE; -- yields TRUE
SELECT NULL > 0 AND FALSE; -- yields FALSE
```
> [!NOTE]  
> A NULL-valued logical expression is treated as FALSE  
> But there is a trap  
> **Beware: two opposite logicql expressions end up with the same result**
```sql
SELECT case when NULL > 0 then 'Apple' else 'Pear' end; -- yields 'Pear'
SELECT case when NOT (NULL > 0) then 'Apple' else 'Pear' end; -- yields 'Pear'
```
* Не знам **е по-голямо нула?** (poisoned) -> Не знам -> FALSE -> круша.
* Не знам **не е по-голямо от нула?** (poisoned) -> Не знам -> FALSE -> круша.

### NULL-handling operators
**IS NULL/IS NOT NULL operator**
```sql
SELECT 3 is null; -- yields FALSE
SELECT 3 is not null; -- yields TRUE
SELECT NULL is null; -- yields TRUE
```
**COALESCE** pseudo-function (of Latin origin) - returns the first non-null argument  
Antivenom, replacing NULLs with default values
```sql
SELECT COALESCE(null, 3); -- yields 3
SELECT COALESCE(null, null, 'домат'); -- yields 'домат'
SELECT COALESCE('yeah', null, 'nope'); -- yields 'yeah'
```
**IS DISTINCT FROM/IS NOT DISTINCT FROM** - NULL-sensitive comparison operator
```sql
SELECT NULL is not distinct from NULL; -- yields TRUE
```
## Character data
Character data types (char, varchar, text) have two critically important attributes: [encoding and collation](https://www.postgresql.org/docs/current/multibyte.html#MULTIBYTE)   
Read this very good stuff on [character encodings](https://thebuild.com/blog/2024/10/27/speaking-in-tongues-postgresql-and-character-encodings/) & [collations and locales](https://thebuild.com/blog/2024/10/25/postgresql-collations-1-gentlemen-this-is-a-football/) (5 minutes read)  
> [!NOTE]  
> My advice: always use **UTF-8**  
> but be prepared that data coming from an external source may use a different encoding  
  
## Temporal data types (i.e. related to time) - DATE, TIME, TIMESTAMP, INTERVAL
<img width="300" alt="image" src="https://github.com/user-attachments/assets/c9be2033-5eb9-4a0c-88ee-9abbf7d73565" />  
  
.  
> [!NOTE]  
> Always use [ISO-8601 notation](https://en.wikipedia.org/wiki/ISO_8601) for textual representation of temporal data types  
> but be prepared that data coming from an external source may use a different notation  

A leap ahead - the `::` operator (PostgreSQL specific) casts the left operand to a certain type (the right one)  
`'2025-10-02'::date` is the same as SQL-standard `CAST('2025-10-02' as date)`

* **DATE data type**
```sql
SELECT current_date;
SELECT '2025-10-02'::date;
SELECT '2025-10-02'::date + 1; -- yields the third of October
```
Data type rules:
* DATE (+ or -) INTEGER -> DATE. The INTEGER is treated as number of days
* DATE + DATE -> :boom:

  
* **TIME data type**  
> [!NOTE]  
> Time is timezone dependent. Always *store* time as **UTC** time and *present* time as per the local culture of the client  
> Always use `time with timezone` (abbreviated `timetz`) and never just `time` (better don't use `time` type at all, use `timestamp`)  
> but be prepared that data coming from an external source may use time without time zone 
```sql
SELECT current_time;
SELECT '16:05:12.00 EET'::timetz;
```

* **TIMESTAMP data type - a moment in time**
> [!NOTE]  
> Timestamps (date and time) are timezone dependent. Always *store* time as UTC time and *present* time as per the local culture of the client  
> Always use `timestamp with timezone` (abbreviated `timestamptz`) and never just `timestamp`  
> but be prepared that data coming from an external source may use timestamp without time zone
```sql
SELECT current_timestamp;
SELECT now();
SELECT '2025-10-02T16:05:12.00 EEST'::timestamptz;
```

* **INTERVAL data type - a period of time, a duration**
```sql
SELECT now() - '2025-10-02T16:05:12.00 EEST'::timestamptz;
```
Data type rules:
* INTERVAL (+ or -) INTERVAL -> INTERVAL
* INTERVAL (* or /) NUMBER -> INTERVAL
* INTERVAL (* or /) INTERVAL -> :boom:
* DATE + INTERVAL -> TIMESTAMP (time 00:00:00 for the date)
* TIME[TZ] + INTERVAL -> TIME[TZ]
* TIMESTAMP[TZ] (+ or -) INTERVAL -> TIMESTAMP[TZ]
* TIMESTAMP[TZ] - TIMESTAMP[TZ] -> INTERVAL
* TIMESTAMP[TZ] + TIMESTAMP[TZ] -> :boom:

